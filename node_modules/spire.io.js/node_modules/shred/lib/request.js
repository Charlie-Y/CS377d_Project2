// Generated by CoffeeScript 1.8.0
(function() {
  var is_array, is_string, parse_url, promise, read, redirects, request, resolve, schemes, to_json, type, user_agent, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  resolve = require("path").resolve;

  parse_url = (require("url")).parse;

  promise = require("when").promise;

  schemes = {
    http: require("http"),
    https: require("https")
  };

  _ref = require("fairmont"), read = _ref.read, type = _ref.type, is_array = _ref.is_array, is_string = _ref.is_string, to_json = _ref.to_json;

  user_agent = "Shred v1.0.0-alpha";

  redirects = [301, 302, 303, 305, 307];

  request = function(_arg, body) {
    var expect, headers, method, redirect, url;
    url = _arg.url, method = _arg.method, headers = _arg.headers, redirect = _arg.redirect, expect = _arg.expect;
    if (url == null) {
      url = typeof window !== "undefined" && window !== null ? window.url : void 0;
    }
    if (method == null) {
      method = "GET";
    }
    if (headers == null) {
      headers = {};
    }
    if (redirect == null) {
      redirect = true;
    }
    if (headers["user-agent"] == null) {
      headers["user-agent"] = user_agent;
    }
    if (expect == null) {
      expect = [200];
    }
    expect = is_array(expect) ? expect : [expect];
    body = body != null ? is_string(body || is_stream(body)) ? body : to_json(body) : void 0;
    return promise(function(resolve, reject) {
      var handler, readBody, _request;
      handler = function(response) {
        var data, statusCode, _error, _ref1, _ref2;
        data = readBody(response);
        if (_ref1 = response.statusCode, __indexOf.call(expect, _ref1) >= 0) {
          return resolve({
            response: response,
            data: data
          });
        } else if ((_ref2 = response.statusCode, __indexOf.call(redirects, _ref2) >= 0) && redirect === true) {
          return _request(response.headers.location);
        } else {
          statusCode = response.statusCode;
          _error = new Error("Expected " + expect + ", got " + statusCode);
          _error.context = {
            response: response,
            data: data
          };
          return reject(_error);
        }
      };
      readBody = function(response) {
        var transform, zlib;
        if (typeof stream !== "undefined" && stream !== null) {
          transform = (function() {
            switch (response.headers["content-encoding"]) {
              case 'gzip':
                zlib = require("zlib");
                return response.pipe(zlib.createGunzip());
              case 'deflate':
                zlib = require("zlib");
                return response.pipe(zlib.createInflate());
              default:
                return response;
            }
          })();
          return transform.pipe(stream);
        } else {
          return promise(function(resolve, reject) {
            body = "";
            response.on("data", function(data) {
              return body += data;
            });
            return response.on("end", function() {
              var error, _ref1;
              if ((_ref1 = response.headers["content-type"]) != null ? _ref1.match(/json/) : void 0) {
                try {
                  return resolve(JSON.parse(body));
                } catch (_error) {
                  error = _error;
                  return reject(error);
                }
              } else {
                return resolve(body);
              }
            });
          });
        }
      };
      return (_request = function(url) {
        var hostname, path, port, protocol, scheme, _ref1;
        _ref1 = parse_url(url), protocol = _ref1.protocol, hostname = _ref1.hostname, port = _ref1.port, path = _ref1.path;
        scheme = protocol.slice(0, -1);
        return schemes[scheme].request({
          hostname: hostname,
          port: port || (typeof window !== "undefined" && window !== null ? window.port : void 0) || (scheme === 'https' ? 443 : 80),
          path: path,
          method: method.toUpperCase(),
          headers: headers
        }).on("response", handler).on("error", function(error) {
          return reject(error);
        }).end(body);
      })(url);
    });
  };

  module.exports = {
    request: request
  };

}).call(this);
