// Generated by CoffeeScript 1.9.2
(function() {
  var assert, describe, ref,
    slice = [].slice;

  ref = require("./helpers"), assert = ref.assert, describe = ref.describe;

  describe("Functional programming functions", function(context) {
    var _, binary, compose, curry, deep_equal, flip, identity, no_op, partial, pipe, ternary, unary, variadic, wrap;
    deep_equal = function(a, b) {
      assert = require("assert");
      try {
        assert.deepEqual(a, b);
        return true;
      } catch (_error) {
        return false;
      }
    };
    context.test("deep_equal", function() {
      assert(deep_equal({
        a: 1,
        b: 2
      }, {
        b: 2,
        a: 1
      }));
      return assert(!deep_equal({
        a: 1,
        b: 2
      }, {
        a: 1,
        b: 1
      }));
    });
    no_op = function() {};
    identity = function(x) {
      return x;
    };
    wrap = function(x) {
      return function() {
        return x;
      };
    };
    curry = function(f) {
      var cf;
      return (cf = function(ax) {
        return function() {
          var bx, cx;
          bx = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          cx = ax.concat(bx);
          if (cx.length < f.length) {
            return cf(cx);
          } else {
            return f.apply(null, cx);
          }
        };
      })([]);
    };
    context.test("curry", function() {
      var f, g;
      f = curry(function(x, y, z) {
        return {
          x: x,
          y: y,
          z: z
        };
      });
      assert(deep_equal(f(1, 2, 3), {
        x: 1,
        y: 2,
        z: 3
      }));
      g = f(3, 2);
      return assert(deep_equal(g(1), {
        x: 3,
        y: 2,
        z: 1
      }));
    });
    _ = {};
    partial = function() {
      var ax, f;
      f = arguments[0], ax = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      return function() {
        var a, bx;
        bx = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        bx = [].concat(bx);
        return f.apply(null, ((function() {
          var i, len, results;
          results = [];
          for (i = 0, len = ax.length; i < len; i++) {
            a = ax[i];
            results.push(a === _ ? bx.shift() : a);
          }
          return results;
        })()).concat(bx));
      };
    };
    context.test("partial", function() {
      var pow, square;
      pow = Math.pow;
      square = partial(pow, _, 2);
      return assert((square(3)) === 9);
    });
    flip = function(f) {
      switch (f.length) {
        case 1:
          return f;
        case 2:
          return function(y, x) {
            return f(x, y);
          };
        case 3:
          return function(z, y, x) {
            return f(x, y, z);
          };
        default:
          return function() {
            var ax;
            ax = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            return f.apply(null, ax.reverse());
          };
      }
    };
    context.test("flip", function() {
      var pow, square;
      pow = Math.pow;
      square = (curry(flip(pow)))(2);
      return assert((square(3)) === 9);
    });
    compose = function() {
      var f, fx, g, i;
      fx = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), f = arguments[i++];
      if (fx.length === 0) {
        return f;
      } else {
        g = compose.apply(null, fx);
        return function() {
          var ax, f_ax, ref1;
          ax = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          if (((ref1 = (f_ax = f.apply(null, ax))) != null ? ref1.then : void 0) != null) {
            return f_ax.then(g);
          } else {
            return g(f_ax);
          }
        };
      }
    };
    context.test("compose", function*() {
      var _parse, _stringify, clone, clone_1, clone_2, clone_3, data, parse, promise, stringify;
      data = {
        foo: 1,
        bar: 2,
        baz: 3
      };
      parse = JSON.parse, stringify = JSON.stringify;
      clone = compose(parse, stringify);
      assert(deep_equal(clone(data), data));
      promise = require("when").promise;
      _stringify = function(x) {
        return promise(function(resolve) {
          return setTimeout((function() {
            return resolve(stringify(x));
          }), 100);
        });
      };
      _parse = function(s) {
        return promise(function(resolve) {
          return setTimeout((function() {
            return resolve(parse(s));
          }), 100);
        });
      };
      clone_1 = compose(parse, _stringify);
      clone_2 = compose(_parse, stringify);
      clone_3 = compose(_parse, _stringify);
      assert(deep_equal((yield clone_1(data)), data));
      assert(deep_equal((yield clone_2(data)), data));
      return assert(deep_equal((yield clone_3(data)), data));
    });
    pipe = flip(compose);
    context.test("pipe", function() {
      var clone, data, parse, stringify;
      data = {
        foo: 1,
        bar: 2,
        baz: 3
      };
      parse = JSON.parse, stringify = JSON.stringify;
      clone = pipe(stringify, parse);
      return assert(deep_equal(clone(data), data));
    });
    variadic = function(f) {
      return function(ax) {
        return f.apply(null, ax);
      };
    };
    unary = function(f) {
      return function(x) {
        return f(x);
      };
    };
    binary = function(f) {
      return function(x, y) {
        return f(x, y);
      };
    };
    ternary = function(f) {
      return function(x, y, z) {
        return f(x, y, z);
      };
    };
    return module.exports = {
      deep_equal: deep_equal,
      no_op: no_op,
      identity: identity,
      wrap: wrap,
      curry: curry,
      _: _,
      partial: partial,
      flip: flip,
      compose: compose,
      pipe: pipe,
      variadic: variadic,
      unary: unary,
      binary: binary,
      ternary: ternary
    };
  });

}).call(this);
